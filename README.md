
# Задание 1
## 1.1
Диаграмма 1-1_asis.puml находится в директории *diagrams*.

### 1
Управление отоплением:
Включение и выключение отопления: Пользователи могут удалённо включать и выключать отопительные системы в своих домах.

Для включения используется метод POST /api/heating/{id}/turn-on, который активирует систему отопления.
Для выключения – метод POST /api/heating/{id}/turn-off.
Установка желаемой температуры: Пользователи могут задавать целевую температуру для системы отопления.

Метод POST /api/heating/{id}/set-temperature принимает параметр temperature и устанавливает желаемую температуру.
Планируется реализация автоматического поддержания заданной температуры, которая будет включена в будущем (в соответствии с TODO-комментарием в коде).
Обновление настроек системы: Пользователи могут изменять конфигурацию отопительной системы, такие как режимы работы, параметры температуры и другие настройки.

Метод PUT /api/heating/{id} позволяет обновлять информацию о системе отопления.
Мониторинг температуры:
Просмотр текущей температуры: Пользователи могут в реальном времени отслеживать текущую температуру в доме через веб-интерфейс.

Для получения текущей температуры используется метод GET /api/heating/{id}/current-temperature, который возвращает значение температуры.
Получение информации о системе отопления: Пользователи могут получить детальную информацию о конкретной системе отопления.
### 2
Архитектура слоев
Controller Layer (Слой контроллеров):

В директории controller находится файл HeatingSystemController.java, который отвечает за обработку входящих HTTP-запросов и маршрутизацию к соответствующим сервисам.
Контроллеры выполняют функции представления данных и взаимодействия с внешним миром через API. Например, обработка запросов на включение/выключение отопления, изменение температуры и получение текущего состояния системы.
DTO Layer (Слой передачи данных):

В директории dto находятся классы, такие как HeatingSystemDto.java, которые используются для передачи данных между слоями контроллеров и сервисов. DTO (Data Transfer Objects) облегчают передачу данных и способствуют инкапсуляции логики преобразования данных.
Entity Layer (Слой сущностей):

В директории entity содержатся сущности, такие как HeatingSystem.java и TemperatureSensor.java, которые представляют объекты доменной модели. Эти сущности отражают таблицы базы данных и определяют структуру хранения данных.
Repository Layer (Слой репозиториев):

В директории repository находятся классы репозиториев, такие как HeatingSystemRepository.java и TemperatureSensorRepository.java. Они служат для взаимодействия с базой данных PostgreSQL. Репозитории используют JPA (Java Persistence API) для выполнения CRUD-операций.
Service Layer (Слой сервисов):

В директории service содержатся классы сервисов, такие как HeatingSystemService.java и HeatingSystemServiceImpl.java, где реализована бизнес-логика приложения. Этот слой управляет взаимодействием между контроллерами и репозиториями, обеспечивая выполнение бизнес-правил.
Config Layer (Конфигурационный слой):

Метод GET /api/heating/{id} возвращает данные о системе в формате JSON.


Монолитная архитектура: Все компоненты тесно связаны и развертываются вместе. Это упрощает разработку и развертывание на начальных этапах, но создает сложности при масштабировании и обновлении. Масштабируемость ограничена, так как монолит сложно масштабировать по частям.

Синхронное взаимодействие: Все запросы обрабатываются последовательно, что может приводить к задержкам при увеличении нагрузки.

Масштабируемость и обновление: Приложение сложно масштабировать частично. Обновление требует перезапуска всей системы, что увеличивает время простоя при обновлении.

Технологический стек: Приложение реализовано на Java с использованием Spring Framework. В качестве базы данных используется PostgreSQL, что предоставляет гибкость в управлении транзакциями и сложными запросами.
### 3
Домен «Управление Устройствами»
Описание: Отвечает за управление системой отопления и другими устройствами: включение, выключение, настройка параметров (например, температуры).
Границы контекста: Включает контроллеры, сервисы и репозитории, связанные с управлением устройствами. Например, HeatingSystemController, HeatingSystemService, и HeatingSystemRepository.

Домен «Мониторинг и Сбор Данных»
Описание: Охватывает сбор и предоставление данных от датчиков температуры, мониторинг текущего состояния.
Границы контекста: Изолирует компоненты, связанные с датчиками, включая сущности, сервисы и репозитории, такие как TemperatureSensor, TemperatureSensorRepository.

Домен «Конфигурация и Настройки Системы»
Описание: Управляет системными параметрами и конфигурациями устройств.
Границы контекста: Включает конфигурационные файлы и сервисы, отвечающие за настройки, такие как классы в директории config.

Домен «Управление Пользователями и Доступом» (опционально)
Описание: Охватывает управление учетными записями пользователей, их правами доступа и авторизацией.
Границы контекста: Включает контроллеры, сервисы и репозитории, связанные с пользователями и правами доступа.

Домен «История и Логирование Событий»
Описание: Сбор и хранение логов и исторических данных для анализа и аудита.
Границы контекста: Изолирует сервисы и репозитории, отвечающие за сбор и хранение данных о событиях.
## 1.2
Все диаграммы в директории *diagrams*

1. Для пользователей и адмминистраторов системы умного дома предусмотрены отдельный веб-интерфейсы.
2. В интерфейсе администратора добавляются конфигурация новых устройств
3. В интерфейсе пользователя предусмотрены функции добавления устройств из имеющихся, задание настроек устройств,
просмотр статистики.
4. Исходя из данных про 100 поселков, 200 домов и 5 устройств в каждом, то можем посчитать, что у нас всего 100000
устройств. Исходя из того, что каждое устройство отправляет сообщение на сервер каждые 10 минут, то мы можем посчитать,
что в секунду в среднем получаем 170 запросов. С запасом возьмем, что и пользователи отправляют запросы
каждые 10 минут. Получим примерно 350 запросов в секунду. Нагрузка должна быть примерно равномерной, но возьмем пиковую
нагрузку в 700 запросов в секунду. Такое количество простых запросов может выдержать один сервер на 8 ядер CPU и 16гб RAM.
То есть, теоретически, можно было бы реализовать новую версию монолитного приложения, в которой была бы возможность
добавлять новые устройства самостоятельно, как администраторам (чтобы эти устройства видели пользователи), так и пользователям 
(чтобы они могли управлять установленными у них дома устройствами). Большое количество сервисов (например, для каждого
типа устройств) делать на данный момент не целесообразно.
5. Были выделены следующие сервисы:
   1. API Gateway - авторизует пользователей и маршрутизует запросы.
   2. Smart Home API - сервис, через который строится связь с устройствами умного дома.
   3. Smart Home CORE - сервис, в котором заложена логика взаимодействия пользователей и устройств
   4. Telemetry Management - сервис, который управляет телеметрией.
   5. Device Management - сервис, который управлеяет устройствами. Через этот же сервер администраторы системы
   добавляют новые устройства.
   6. Monitoring - сервис логирования событий.

**Скорректировал связи "Kafka - Smart Home API" и "Kafka - Device Management". Подправил описание и сделял стрелки двусторонними.**

## 1.3
**ER-диаграмма находится в директории diagrams**

Events - это причина, EventHistory - следствие. Например, сработал датчик движения. Это запись в таблице Events. В 
EventsHistory будет, например, три записи - включен свет, включена запись камеры видеонаблюдения, отправлено сообщение 
владельцу. 
## 1.4
Описание api для сервисов управления устройствами и сервиса телеметрии находится в директории *apis*

**Подправил API.**

# Задание 2
1. Запуск контейнера с миникубом **minikube start --driver=docker**
2. В директории k8s ввести **kubectl apply -f .**
Скриншот в папке k8s
